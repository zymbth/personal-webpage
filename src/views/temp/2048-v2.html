<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <script src="https://unpkg.com/vue@next"></script>
    <title>2048</title>
  </head>
  <body>
    <div id="app">
      <div class="panel-wrap">
        <div id="panel">
          <div v-for="row in [4,4,4,4]">
            <div v-for="cell in row" class="cell">
              <div class="cell-block"></div>
            </div>
          </div>
        </div>
        <div id="opt" style="text-align:center">
          <button @click="handleOpt('up')">↑</button>
          <br/>
          <button @click="handleOpt('left')">←</button>
          <button @click="handleOpt('down')">↓</button>
          <button @click="handleOpt('right')">→</button>
        </div>
      </div>
    </div>
    <script>
      const App = {
        data() {
          const Block = function(row, col) {
            this.row = row
            this.col = col
            this.value = 2

            this.sum = () => {
              this.value *= 2
            }
            this.move = (row,col) => {
              this.row = row
              this.col = col
            }
          }
          return {
            blocks: [],
            data: [
              [undefined,undefined,undefined,undefined],
              [undefined,undefined,undefined,undefined],
              [undefined,undefined,undefined,undefined],
              [undefined,undefined,undefined,undefined]
            ],
            failedFlag: false,
            colors: [
              '#cef4f5','#91f3f2','#01dcf2','#00a7f5','#749ffb','#0177e1','#315091','#0442e3',
              '#6156d9','#a580e9','#b063ff','#9d00e5','#8a01ed'
            ],
            loading: false,
            started: false,
          };
        },
        created() {
          window.addEventListener('keyup', ({ keyCode }) => {
            this.handleOpt({
              37: 'left',
              39: 'right',
              38: 'up',
              40: 'down'
            }[keyCode])
          })
        },
        methods: {
          handleOpt(type) {
            if(this.loading) return
            if(this.failedFlag) return
            if(!['left','right','up','down'].includes(type)) return
            this.loading = true
            this.moveAndMerge(type).finally(_ => {
              this.loading = false
            })
          },
          // 移动并合并块
          moveAndMerge(type) {
            return new Promise((resolve,reject) => {
              let tmpData, flag
              if(['up','down'].includes(type)) {
                tmpData = this.transMatrix(this.data)
                flag = true
              } else {
                tmpData = this.data
                flag = false
              }
              // 是正方向？
              let direction = ['up','left'].includes(type)
              if(!direction) {
                tmpData = this.reserveRow(tmpData)
                flag = true
              }
  
              let movedFlag = false
              tmpData.forEach((p, rIdx) => {
                // 移动至一端
                let count = 0
                p.forEach((p1,idx) => {
                  const currBlock = this.findBlockByPosi(rIdx, idx)
                  if(!currBlock) return
                  if(!movedFlag && idx !== count) movedFlag = true
                  currBlock.move(currBlock.row, count++)
                })
                // 同数相邻叠加
                if(count > 1) {
                  let count1 = -1
                  for(let i = 0; i < p.length; i++) {
                    const currBlock = this.findBlockByPosi(rIdx, i)
                    if(!currBlock) continue
                    const nextBlock = this.findBlockByPosi(rIdx, i+i)
                    count1++
                    if(currBlock.value === nextBlock.value) {
                      if(!movedFlag) movedFlag = true
                      currBlock.move(rIdx, count1)
                      currBlock.sum()
                      this.removeBlockByPosi(rIdx, i+1)
                      i++
                    } else {
                      currBlock.move(rIdx, count1)
                    }
                  }
                }
              })
              if(!this.started) {
                this.started = true
              } else {
                if(!movedFlag) {
                  if(!this.checkMovable(this.data)) {
                    this.failedFlag = true
                    reject('Game Over')
                    alert('Game Over')
                  } else {
                    resolve()
                  }
                  return
                }
              }

              const { rowIdx, colIdx } = this.createBlock(tmpData)
              let [rowIdx1, colIdx1] = [rowIdx, colIdx]
              if(!direction) {
                tmpData = this.reserveRow(tmpData);
                colIdx1 = 3 - colIdx1
              }
              if(['up','down'].includes(type)) {
                tmpData = this.transMatrix(tmpData)
                ;[colIdx1, rowIdx1] = [rowIdx1, colIdx1]
              }
              if(flag) {
                this.data = this.copyData(tmpData)
              }
              this.appearTransition(rowIdx1, colIdx1)
                .then(_ => resolve())
                .catch(err => reject(err.message || err))
            })
          },
          // 生成块
          createBlock(arr) {

          },
          // 二维矩阵转置
          transMatrix(arr) {
            let res = []
            for(let i = 0; i < arr.length; i++) {
              for(let j = 0; j < arr[i].length; j++) {
                if(!res[j]) res[j] = []
                res[j][i] = arr[i][j]
              }
            }
            return res
          },
          reserveRow(arr) {
            return arr.reduce((prev,curr) => {
              prev.push(curr.slice().reverse())
              return prev
            }, [])
          },
          copyData(arr) {
            return arr.map(p => {
              return p.map(p1 => p1)
            })
          },
          getBlockBg(value) {
            return this.colors[
              value ? Math.log2(value) : 0
            ] ?? this.colors.at(-1)
          },
          // 出现特效
          appearTransition(rowIdx,colIdx) {
            return new Promise((resolve,reject) => {

            })
          },
          checkFullPanel(arr) {
            return arr.every(p => p.every(Boolean))
          },
          checkMovable(arr) {
            return !this.checkFullPanel(arr)
              || arr.some(p => p.some((p1,idx) => p1 === p[idx+1]))
              || this.transMatrix(arr).some(p => p.some((p1,idx) => p1 === p[idx+1]))
          },

          findBlockByPosi(row, col) {
            return this.blocks.find(b => b.row === row && b.col === col)
          },
          createBlockByPosi(row, col) {
            const newBlock = new Block(row,col)
            this.blocks.push(newBlock)
            return newBlock
          },
          removeBlockByPosi(row, col) {
            const target = this.blocks.findIndex(b => b.row === row && b.col === col)
            if(target > -1) this.blocks.splice(target, 1)
          }
        }
      };
      const app = Vue.createApp(App);
      app.mount("#app");
    </script>
    <style>
      /* @keyframes testFrame {
        from {opacity: 0;}
        to {opacity: 1;}
      }
      .appear {
        animation-name: testFrame;
        animation-duration: 0.15s;
        animation-timing-function: ease-in-out;
        animation-iteration-count: unset;
      } */
      html,body {margin:0}
      #app {
        height: calc(100vh - 40px);
        max-width: 750px;
        margin: 0 auto;
        padding: 20px;
        box-shadow: 0 0 4px 2px rgb(0,0,0,.1);
      }
      .panel-wrap {
        text-align: center;
      }
      #panel {
        display: inline-block;
        padding: 10px;
        margin-bottom: 20px;
        box-shadow: 0 0 4px 2px rgb(255,0,0,.1);
        border-radius: 8px;
        background-color: #d5fffe;
      }
      #opt {
        text-align: center;
      }
      #opt>button {
        font-size: 24px;
        width: 50px;
        padding: 6px;
        margin: 6px;
      }
      #panel>div {
        display: flex;
      }
      .cell {
        width: 80px;
        height: 80px;
        margin: 8px;
        color: #fff;
        font-size: 24px;
        font-weight: bold;
        line-height: 80px;
        text-align: center;
        box-shadow: 4px 4px 0px 0px rgb(0, 0, 255, .1);
        background-color: #cef4f5;
      }
      .cell-block {
        width: 100%;
        height: 100%;
        background-color: #cef4f5;
      }
    </style>
  </body>
</html>